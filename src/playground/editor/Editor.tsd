import { HStack, VStack } from "@dlightjs/components";
import { Watch } from "@dlightjs/decorators";
import { CustomNode, View } from "@dlightjs/dlight";
import { Env, img, PropState, required, span, State } from "@dlightjs/useless";
import { div } from "@dlightjs/useless";
import { css } from "@dlightjs/emotion";
import * as monaco from "monaco-editor"
import {TranspilerProjectDto} from "../../service/input.dto"
import { indexCode } from "./const"
import { AddIcon } from "../svgImg/AddIcon.tsd"
import { DeleteIcon } from "../svgImg/DeleteIcon.tsd";

interface IModelStore {
    tabName: string,
    model: any,
    state: any
}


function uid() {
    return Math.random().toString(32).slice(2, 8)
}

export class Editor extends View {
    // ---- prop
    @PropState projectBody: TranspilerProjectDto = required
    @PropState currTabId = required
    @PropState currTagName = required

    // ---- state
    @State modelStores: {[key: string]: IModelStore} = {}
    @State isTabEdit = ""

    @Env theme = required
    editorTheme = this.theme.name === "light" ? "vs" : "vs-dark"
    themeChanged = function() {
        monaco.editor.setTheme(this.editorTheme)
    }.call(this)


    // ---- element
    editorEl?: HTMLElement
    tagElements = {}

    // ---- member
    prevTabId = ""
    editor?: any
    changedText = ""

    alterCurrTagName = function() {
        this.currTagName = this.modelStores[this.currTabId]?.tabName ?? "index"
    }.call(this)


    // ---- method
    addTab(tabName: string, defaultValue="", language="typescript") {
        const model = monaco.editor.createModel(defaultValue, language)
        const tabId = uid()
        this.modelStores[tabId] = {
            tabName, model, state: null
        }
        this.modelStores = {...this.modelStores}
        this.switchTab(tabId)
    }

    switchTab(tabId: string) {
        if (this.modelStores[this.currTabId]) this.modelStores[this.currTabId].state = this.editor.saveViewState()
        const modelStore = this.modelStores[tabId] ?? Object.values(this.modelStores).find(store => store.tabName === "index")!
        this.editor.setModel(modelStore.model)
        this.editor.restoreViewState(modelStore.state)
        this.prevTabId = this.currTabId
        this.currTabId = tabId
    }

    geneNewTabName() {
        const tabNames = Object.values(this.modelStores).map(store => store.tabName)
        let i = 0
        while (tabNames.includes(`tab${i === 0 ? "" : i}`)) {
            i ++
        }
        return i === 0 ? "tab" : `tab${i}`
    }

    getProjectBody() {
        const body: TranspilerProjectDto = {
            project: [],
            language: "jsd"
        }
        for (let modelStore of Object.values(this.modelStores)) {
            body.project.push({
                path: `/${modelStore.tabName}.tsd`,
                body: modelStore.model.getValue()
            })
        }
        this.projectBody = body
    }

    onKeyDown = (e: any) => {
        if (e.key === "s" && e.metaKey) {
            e.preventDefault()
            this.getProjectBody()
        }
    }

    bindCancelEditableTag() {
        document.addEventListener("click", (event)=>{
            if(event.target != this.tagElements[this.currTabId] && this.isTabEdit){
                this.isTabEdit = ""
                if(this.changedText){
                    this.modelStores[this.currTabId].tabName = this.changedText
                }
                this.modelStores = {...this.modelStores}
            }
        })
    }

    initEditor() {
        this.editor = monaco.editor.create(this.editorEl!,{
            theme: this.editorTheme,
            minimap: { enabled: false },
            automaticLayout: true
        })
        this.addTab("index", indexCode)
    }

    // ---- lifecycle
    didMount() {
        this.editorEl?.addEventListener("keydown", this.onKeyDown)
        this.bindCancelEditableTag()
        this.initEditor()
        this.getProjectBody()
    }
    willUnmount(_els: HTMLElement[], _node: CustomNode): void {
        this.editorEl?.removeEventListener("keydown", this.onKeyDown)
        this.editor?.dispose()
        this.getProjectBody()
    }

    // ---- views
    @View
    Tab({tabName, tabId}):any {
        HStack()
            .alignment("center")
            .spacing(0)
        {
            div()
                .className(tabNameCss)
                .className(tabId === this.currTabId ? activeTabNameCss: "")
            {
                span(tabName)
                    .contentEditable(this.isTabEdit === tabId)
                    .element(this.tagElements[tabId])
                    .oninput((e: any) => {
                        this.changedText = e.target.innerText
                    })     
                    .ondblclick(() => {
                        this.changedText = tabName
                        this.isTabEdit = tabId
                        this.tagElements[tabId].focus()
                    })         
                    .className(tabNameSpanCss)
                span(".tsd")                
            }
            
            if (tabName !== "index") {
                DeleteIcon()
                    .onclick((event:any)=>{
                        event.stopPropagation()
                        if (this.currTabId === tabId) this.switchTab(this.prevTabId)
                        this.modelStores[tabId].model.dispose()
                        delete this.modelStores[tabId]
                        delete this.tagElements[tabId]
                        this.modelStores = {...this.modelStores}
                    })
            }
        }
    }


    @View
    Tabs() {
        div()
            .className(tabWrapCss)
        {
            HStack()
                .alignment("center")
            {
                for (let tabId of Object.keys(this.modelStores)) { 
                    div()
                        .onclick(() => {
                            this.switchTab(tabId)
                        })
                        .className(tabCss)
                        ._backgroundColor(tabId === this.currTabId ? "#0B2940": "transparent")
                    {
                        // @ts-expect-error
                        this.Tab()
                            .tabId(tabId)
                            .tabName(this.modelStores[tabId].tabName)
                    }
                }
                AddIcon()
                    .onclick(() => {
                        this.addTab(this.geneNewTabName())
                        this.getProjectBody()
                    })
            }
        }
    }

    Body() {
        VStack()
            .spacing(0)
        {
            this.Tabs()
            div()
                .element(this.editorEl)
                .className(editorCss)
        }
    }
}


const editorCss = css`
    width: 600px;
    height: calc(100vh - 30px);
`

const tabCss = css`
    padding: 0px 10px ;
    height: 30px;
`

const tabNameCss = css`
    height: 30px;
    line-height: 30px;
    font-size: 18px;
    color: #8AA4DA;
    background-color: transparent;
    border-width: 0px;
`

const tabNameSpanCss = css`
    padding: 2px;
    cursor: pointer;
`

const activeTabNameCss = css`
    color: #F88070;
`

const tabWrapCss = css`
    background-color: rgb(30, 30, 30);
    padding: 0px 10px;
    width: 100%;
    margin: 2px 0;
`
